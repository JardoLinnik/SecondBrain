Декоратор - это структурный патерн проектирования. В Python реализован как функция. Расширяет функционал функции, но не меняет ее исходный код.

@decotator - синтаксический сахар для использования декоратора.
function = decorator (function) - то же самое, но без сахара.
### @functools.wraps(func)
 встроенный декоратор  из стандартной библиотеки Python, который используется для упрощения создания собственных декораторов. Он сохраняет метаданные исходной функции.
При использовании декоратора он возвращает обертку - дополненую функцию не сохраняя метаданные функции и меняя их на метаданные обертки. Встроенный декоратор сохраняет эти данные и копирует их в обертку.

### Одноразовое декорирование:
decorator(function)(1)

### Порядок выполнения декоратора : 
Выполняется тот декоратор, что ближе к функции.
`@deco1`
`@deco2`
`def function ():`

@ deco1 обхватит и @deco2 и функцию. 
`fucntion = deco1(deco2(fUnction))`

### Декоратор с аргументом

Декоратор с аргументами состоит из двух слоев функций. Первый слой принимает аргументы, а второй слой — это собственно декоратор, который обрабатывает функцию.

`def decorator_with_args(arg1, arg2):`    
	`def actual_decorator(func):`      
		`def wrapper(*args, **kwargs):`          
			`#Логика декоратора, использующая arg1, arg2`            
			`return func(*args, **kwargs)`      
		`return wrapper    
		`return actual_decorator`

### Декоратор ассинхронной функции


### Декоратор класс



