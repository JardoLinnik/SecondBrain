> Для работы с графами я использую несколько подходов к обходу/поиску в зависимости от задачи.  
> Самые базовые — **BFS** и **DFS** — они покрывают большинство задач по обходу и получению структуры графа.  
> Для задач с весами и оптимизацией — `Dijkstra`, `Bellman-Ford`, `A*`. Для зависимостей и планирования — **топологическая сортировка (Kahn)**. Для анализа компонентов и мошеннических связей — **поиск сильно связанных компонент (Kosaraju / Tarjan)**.  
> В продакшне в Т-Банке мы обычно комбинируем эти алгоритмы с графовыми базами (Neo4j/JanusGraph) или распределёнными движками (Spark GraphX/GraphFrames) — выбор зависит от размера данных и требований к latenсy.

---

## Перечень основных способов обхода / поиска и когда их применять

### 1) BFS — Breadth-First Search

- Идея: уровневый обход (очередь).
    
- Используется когда нужен **минимальный по числу рёбер путь** в не взвешенном графе, или поиск ближайших соседей.
    
- Сложность: `O(V + E)` по времени, `O(V)` по памяти.
    

**Кейс в Т-Банке:** найти кратчайшую цепочку транзакций между двумя клиентами (проверка возможной цепочки отмывания).

**Код (Python):**

`from collections import deque  def bfs(graph, start, target):     q = deque([start])     prev = {start: None}     while q:         node = q.popleft()         if node == target:             break         for nb in graph[node]:             if nb not in prev:                 prev[nb] = node                 q.append(nb)     # восстановить путь     if target not in prev:         return None     path, cur = [], target     while cur is not None:         path.append(cur)         cur = prev[cur]     return list(reversed(path))`

---

### 2) DFS — Depth-First Search (рекурсивный / стек)

- Идея: идём в глубину до конца, затем откатываемся.
    
- Применение: топологическая сортировка, поиск компонент, проверка циклов, обход деревьев.
    
- Сложность: `O(V + E)`.
    

**Кейс в Т-Банке:** обход связей клиента для построения полного профиля (получить все связанные аккаунты, контрагенты), детекция цепочек.

**Код (рекурсивный):**

`def dfs(graph, node, visited):     visited.add(node)     for nb in graph[node]:         if nb not in visited:             dfs(graph, nb, visited)`

---

### 3) Топологическая сортировка (Kahn / DFS-вариант)

- Для ориентированных ацикличных графов (DAG).
    
- Применение: планирование задач, порядок выполнения ETL/микросервисов, разрешение зависимостей.
    
- Сложность: `O(V + E)`.
    

**Кейс в Т-Банке:** определение порядка запуска batch-job’ов или DAG в Airflow с учётом зависимостей.

**Код (Kahn):**

`from collections import deque, defaultdict  def topological_sort(nodes, edges):     indeg = defaultdict(int)     g = defaultdict(list)     for u, v in edges:         g[u].append(v)         indeg[v] += 1     q = deque([n for n in nodes if indeg[n] == 0])     order = []     while q:         u = q.popleft()         order.append(u)         for v in g[u]:             indeg[v] -= 1             if indeg[v] == 0:                 q.append(v)     if len(order) != len(nodes):         raise ValueError("Cycle detected")     return order`

---

### 4) Поиск сильносвязанных компонент — Kosaraju / Tarjan

- Нужны для выделения кластеров, замыкания циклов.
    
- Сложность: `O(V + E)`.
    

**Кейс в Т-Банке:** обнаружение мошеннических коллабораций (кольцевые переводы между множеством аккаунтов).

---

### 5) Dijkstra (кратчайший путь для взвешенных неотрицательных ребёр)

- Идея: жадный выбор ближайшей вершины с помощью кучи.
    
- Сложность: `O((V + E) log V)` при реализации с heap.
    
- Применение: маршрутизация, минимальные издержки.
    

**Кейс в Т-Банке:** найти “наиболее дешёвый” путь перевода через сервисы с комиссиями (минимизация комиссии/латентности между узлами).

**Код (Python heapq):**

`import heapq  def dijkstra(graph, start):     dist = {start: 0}     pq = [(0, start)]     while pq:         d, u = heapq.heappop(pq)         if d > dist[u]: continue         for v, w in graph[u]:  # list of (neighbor, weight)             nd = d + w             if v not in dist or nd < dist[v]:                 dist[v] = nd                 heapq.heappush(pq, (nd, v))     return dist`

---

### 6) Bellman-Ford

- Работает с отрицательными весами, но медленнее: `O(V * E)`.
    
- Применяется, если могут быть отрицательные ребра и нужно обнаружить отрицательные циклы.
    

---

### 7) A* (A-star)

- Dijkstra + эвристика (heuristic) для ускорения поиска кратчайшего пути.
    
- Используется если есть информативная эвристика (евклидово расстояние и т.п.).
    
- Применимость в банке: редко, разве что в задачах оптимизации маршрутов/логистики.
    

---

### 8) Bidirectional Search (двунаправленный поиск)

- Запускается одновременно от стартовой и целевой вершин; встреча в середине даёт выигрыш ~ вдвое.
    
- Эффективен для очень больших графов, где важна latency.
    

**Кейс в Т-Банке:** быстрый поиск связи между двумя клиентами в графе с сотнями миллионов вершин (предварительная фильтрация + двунаправленный BFS).

---

### 9) Iterative Deepening DFS (IDDFS)

- Комбинация DFS и BFS: запускаем DFS с ограничением глубины 1,2,3...
    
- Применяется когда глубина решения небольшая, а память ограничена (полезно в задачах поиска путей в «широких» графах).
    

---

## Инструменты и стек, которые используешь в Т-Банке

- **Neo4j / Cypher** — интерактивные графовые запросы (корреляция аккаунтов, быстрый traversal).
    
- **JanusGraph + Cassandra / HBase** — масштабируемые графовые хранилища.
    
- **NetworkX** — быстро прототипировать алгоритмы локально (не для больших данных).
    
- **Spark GraphX / GraphFrames** — распределённые вычисления (анализ графов на TB данных).
    
- **SQL (WITH RECURSIVE)** и **ClickHouse** — для простых графовых выборок и временных связей.
    
- **Gremlin** — для traversal в некоторых graph databases.
    
- **Python (heapq, collections.deque, bisect)** — реализация алгоритмов в микросервисах/пайплайнах.
    

---

## Советы по выбору алгоритма в продакшне

1. **Если граф большой и нужен «короткий путь по ребрам» → BFS / Bidirectional BFS.**
    
2. **Если веса есть (комиссии, latency) → Dijkstra / A* (если есть хорошая эвристика).**
    
3. **Для зависимостей и планирования → топологическая сортировка (Kahn).**
    
4. **Для поиска мошеннических кругов → SCC (Tarjan/Kosaraju).**
    
5. **На больших данных — переносим логику в graph DB или распределённую обработку (Spark).**