Из-за того, что в большинстве ОС операции чтения и записи в файл на диске являются блокирующими, чтение файла (сист. вызов read()) блокирует другие одновременные чтения файла, пока данные не будут прочитаны с диска. Аналогично запись в файл (write()) блокирует другие записи. Важно, что одновременные чтение и запись друг друга по умолчанию не блокируют, если не настроен механизм блокировки в приложении. При этом чтение во время записи может извлечь незавершенную запись в файл.  
Сама либа aiofiles написана довольно кринжово - при чтении файла создается отдельный поток (через ThreadPoolExecutor, завёрнутый в asyncio), в котором производится блокирующий системный вызов read() (write()). Этот вызов блокирует сам поток и, соответственно, чтение (запись) другими потоками, но при этом не блокирует выполнение других корутин внутри Event Loop, т.к. он находится в другом потоке. Получается, что тут всего лишь имитируется асинхронность путем вынесения блокирующей операции в отдельный поток.  
  
Справка:  
  
*Файловый дескриптор - числовой идентификатор, с помощью которого ОС работает с файлом. Т.е. системный вызов open() возвращает файловый дескриптор, а write() и read() получают его на вход и понимают, с каким файлом надо работать.  
К стандартному файловому дескриптору относится файл, но ещё есть дургие файловые дескрипторы - сокеты, каналы, устройства.  
  
Дополнение про одновременное удаление файла потоками:  
Если один поток изменяет файл, а второй удаляет его, файл удалится из каталога, но его содержимое останется существовать в файловой системе пока не закроются все файловые дескрипторы для этого файла.  
  
Дополнение про процессы:  
Каждый процесс может читать/писать файл одновременно с другими процессами, т.к. у каждого процесса свой файловый дескриптор.