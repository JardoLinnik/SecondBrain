* ### Вытесняющая многозадачность  
Операционная система использует таймер, который периодически прерывает выполнение текущего потока и передаёт управление другому потоку. Этот процесс называется вытесняющей многозадачностью. Таймер можно настроить через модуль sys в Python. Также у каждого потока есть приоритет и ОС чаще даёт выполнения потокам с бОльшим приоритетом.  
  
def task1():  
while True:  
x = 0  
for i in range(100000):  
x += i  
print("Task 1 is running")  
  
def task2():  
while True:  
y = 0  
for i in range(100000):  
y += i  
print("Task 2 is running")  
  
* ### Блокирующие операции  
Поток может добровольно уступить управление, когда он выполняет блокирующую операцию, такую как ввод-вывод  
  
def read_file():  
print("Opening file...")  
with open("example.txt", "r") as file:  
print("Reading file...")  
content = file.read() # Блокирующая операция: чтение данных из файла  
print("File read complete.")  
print(content)  
  
def other_task():  
print("Starting other task...")  
for i in range(5):  
print(f"Other task iteration {i}")  
  
* ### Явная передача управления  
Поток может сам явно уступить управление другим потокам, используя time.sleep(0) или threading.Event().wait(timeout=0)  
  
def task1():  
for i in range(1_000):  
print(f"Task 1 - Iteration {i}")  
time.sleep(0) # Явное уступление управления другим потокам  
  
def task2():  
for i in range(1_000):  
print(f"Task 2 - Iteration {i}")  
time.sleep(0) # Явное уступление управления другим потокам  
  
Итог: ОС переключает потоки, но поток для своего выполнения должен сначала перехватить GIL. То, как часто и когда отпускать GIL, определяет интерпретатор. Получается, что снаружи потоками управляет ОС, но внутри она ограничивается поведением GIL и интерпретатора.