> Если нужна **очередь задач с гарантированной обработкой, гибкой маршрутизацией, низкой задержкой и контролем ретраев** — берём **RabbitMQ**.  
> Если нужен **поток событий с историей, горизонтальным масштабированием и высокой пропускной способностью** — берём **Kafka**.  
> В реальных системах (как у нас в Т-Банке) часто используется **гибрид**: Kafka для событий/аналитики/интеграций, RabbitMQ — для фоновых job’ов, ретраев и workflow.

---

## Чек-лист выбора (за 30 секунд)

- **Модель**: «очередь задач» → RabbitMQ; «событийный лог/стрим» → Kafka.
    
- **История сообщений нужна?** Да → Kafka; Нет → RabbitMQ.
    
- **Черезput (десятки–сотни тыс./сек и выше)?** Высокий → Kafka; Средний → RabbitMQ.
    
- **Латентность критична (<10–20 мс per message)?** Да → RabbitMQ; Можно 10–100+ мс → Kafka.
    
- **Сложная маршрутизация (topic/fanout/headers, приоритеты, TTL/DLQ)?** → RabbitMQ.
    
- **Exactly-once/реплей/новые консьюмеры «с начала»?** → Kafka.
    
- **Оверхед эксплуатации** готов терпеть? → Kafka сложнее; RabbitMQ проще.
    

---

## Куда что: таблица по критериям

|Критерий|RabbitMQ|Kafka|
|---|---|---|
|Модель|Очереди (point-to-point, pub/sub через exchange)|Лог (append-only), партиции|
|Хранение|Удаляет после ack|Retention (часы/дни/недели), реплей|
|Маршрутизация|Богатые exchange’ы: direct/topic/fanout/headers, приоритеты, TTL, DLQ|Простая: topic + ключ партиции|
|Производительность|Хорош для тысяч–десятков тыс./сек|Отлично для сотен тыс.–миллионов/сек|
|Латентность|Очень низкая, per-message ack|Batch-ориентированная, near-real-time|
|Гарантии|At-least-once (ack/nack), DLQ|At-least-once/Exactly-once (tx producer/consumer)|
|Эксплуатация|Проще развернуть/тюнить|Сложнее (партиции, репликация, ретеншн, мониторинг)|
|Use-cases|Фоновые задачи, workflow, ретраи, уведомления|Event streaming, интеграции, аналитика, CDC|

---

## Типовые сценарии

### Когда **RabbitMQ**

- **Очереди задач**: рассылка писем/пушей, генерация отчётов, image/video processing.
    
- **Workflow c ретраями и DLQ**: бизнес-процессы с пошаговой обработкой.
    
- **Сложная маршрутизация**: один продюсер → разные потребители по ключам/шаблонам.
    
- **Жёсткие SLO по латентности** на единичных событиях.
    

### Когда **Kafka**

- **Событийная шина**: бизнес-события `transaction_created`, `client_updated`.
    
- **Историчность и реплей**: подключение новых консьюмеров «с начала».
    
- **Высокий throughput**: телеметрия, логи, клики, скоринг-потоки.
    
- **Интеграции и CDC**: Kafka Connect (Postgres→ClickHouse/S3/ES), Schema Registry.
    

---

## Анти-паттерны (чтобы не попасть)

- Тянуть **Kafka ради пары писем в фоне** → оверкилл: бери RabbitMQ/SQS.
    
- Пытаться в RabbitMQ хранить «историю событий на неделю» → не его модель.
    
- Использовать Kafka как «RPC» для синхронных запросов → не то; для RPC — REST/gRPC.
    
- Втыкать оба «на всякий случай» без разделения зон ответственности → усложнение поддержки.
    

---

## Как делаем в Т-Банке (практика)

- **Kafka**: центральная шина событий. Все микросервисы публикуют доменные события в топики; подписчики (скоринг, антифрод, аналитика, нотификации) читают группы. Retention 7–30 дней, репликация 3, Schema Registry (Avro/Proto), Connect для CDC и загрузки в DWH (ClickHouse/S3). Exactly-once — там, где важна идемпотентность финансовых событий.
    
- **RabbitMQ**: фоновые job’ы и workflow. Очереди с приоритетом/TTL/DLQ, ретраи с отложенной повторной доставкой, per-consumer prefetch. Используем для пушей/SMS, отчётов, «умных» ретраев платёжных сценариев.
    

Гибрид даёт: **масштаб и историю** от Kafka + **тонкую маршрутизацию и контроль ретраев** от RabbitMQ.

---

## Быстрый «decision tree»

1. Нужна **история/реплей/новые консьюмеры читают прошлое**? → **Kafka**.
    
2. Нужны **ретраи, DLQ, приоритеты, гибкая маршрутизация, очень низкая задержка**? → **RabbitMQ**.
    
3. Нужны **оба свойства** (история + ретраи/workflow)? → **Kafka для событий** + **RabbitMQ для задач/ретраев**.
    
4. Throughput **>100k msg/s** стабильно? → скорее **Kafka**.
    
5. Команда/OPS **не готова к сложной эксплуатации**? → по возможности **RabbitMQ** или managed Kafka.
    

---

## Микро-сниппеты (как это выглядит)

**RabbitMQ (DLQ/TTL):**

`# очередь retry с TTL и маршрутизацией в основную после истечения x-dead-letter-exchange: main-ex x-message-ttl: 60000  # 60s`

**Kafka (идемпотентный продюсер + acks=all):**

`enable.idempotence=true acks=all max.in.flight.requests.per.connection=1 retries=∞`

---

## Итог

- Выбирай **по модели и требованиям**: очередь задач с ретраями → RabbitMQ; событийный лог с историей и масштабом → Kafka.
    
- Не бойся **гибрида**: это нормальная зрелая архитектура.
    
- Решение обосновывай **SLA/SLO**: latency, throughput, гарантии доставки, историчность, операционные риски.