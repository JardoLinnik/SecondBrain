1. Формат сообщений (текст vs бинарный)  
* HTTP/1.1:  
- Использует текстовый формат заголовков и тела. Запросы и ответы — это строки с методами (GET / POST / …), URI, протоколом (HTTP/1.1), заголовками и т.д.  
- Парсинг заголовков требует разбора строк, переносов, разделителей : и т.п.  
* HTTP/2:  
- Использует бинарный формат на уровне «фреймов» (frames).  
- Все данные (заголовки, тело, служебные сигналы) разбиваются на отдельные бинарные фреймы, которые проще и быстрее парсить машинно (нет строкового парсинга).  
- С точки зрения разработчика это обычно «прозрачно»: клиентские библиотеки (curl, браузеры и т. д.) сами собирают/разбирают эти фреймы.  
* Итог: HTTP/2 более эффективен при обработке, так как нет «строкового» парсинга, всё организовано в бинарном «потоке фреймов».  
2. Мультиплексирование (multiplexing)  
* HTTP/1.1:  
- Каждый запрос-ответ идёт последовательно в рамках одного TCP-соединения. До HTTP/1.1 существовало ограничение (Persistent Connection), когда следующий запрос ждал окончания предыдущего (head-of-line blocking).  
- Браузеры, чтобы ускорить загрузку, открывают несколько TCP-соединений к одному серверу (по 4–6 подключений), распараллеливая запросы, но это повышает нагрузку на сетевую подсистему (каждый TCP-сокет — отдельное соединение с размноженной инициализацией, congestion control и т. д.).  
* HTTP/2:  
- Позволяет в одном TCP-соединении вести несколько «параллельных» потоков (streams). Каждый запрос/ответ разбивается на фреймы и переплетается с фреймами других запросов.  
- Клиент может одновременно (мультиплексированно) отправить запросы на изображения, скрипты, стили, а сервер может перемежать ответы.  
- Решается проблема head-of-line blocking на уровне HTTP (но важно помнить, что на уровне TCP определённый HOL-blocking остаётся, однако мультиплексирование всё же существенно ускоряет загрузку веб-страниц).  
* Итог: HTTP/2 даёт мультиплексированные запросы/ответы в одном соединении, что повышает эффективность и уменьшает задержки.  
3. Сжатие заголовков (HPACK)  
* HTTP/1.1:  
- Заголовки отправляются как текст без специального «stateful» сжатия. На каждой передаче повторяются заголовки вроде User-Agent, Cookie, Accept и пр.  
- Используются, правда, общие компрессии (например, gzip), но редко для самих заголовков (в основном для тела ответа).  
* HTTP/2:  
- Внедрён специальный механизм HPACK — «Header Compression for HTTP/2».  
- Он хранит таблицу (dynamic/static table) часто повторяющихся заголовков и отправляет лишь краткие «ключи» или диффы.  
- При множественных запросах/ответах между клиентом и сервером заголовки (например, Host, Accept, User-Agent) перестают дублироваться в полном объёме — отправляются только ссылки/индексы.  
* Итог: в HTTP/2 заголовки компрессируются более эффективно, уменьшая общий трафик.  
4. Server Push  
* HTTP/1.1:  
- Для загрузки дополнительных ресурсов (CSS, JS, изображения) клиент должен явно сделать запрос, получив HTML с ссылками на эти ресурсы.  
* HTTP/2:  
- Поддерживает Server Push: сервер может заранее отправить (пушить) клиенту ресурсы, не дожидаясь запроса (например, CSS, JS), если уверен, что они понадобятся.  
- Это может ускорить загрузку, так как клиент может получить ресурсы «проактивно». Однако в реальных проектах эта фича используется сравнительно редко: возникает путаница с кешированием, при повторной загрузке страницы можно отправлять «лишний» push. (В HTTP/3 некоторые браузеры и вовсе убрали поддержку push в пользу 103 Early Hints.)  
* Итог: HTTP/2 даёт механизм Server Push, но его польза спорна и зависит от конкретных сценариев.  
5. Скорость и производительность  
* HTTP/1.1:  
- При загрузке страницы с множеством ресурсов (изображений, стилей, скриптов) клиент обычно поднимает несколько параллельных соединений, чтобы скачивать несколько объектов одновременно.  
- При каждом соединении — отдельные накладные расходы (TCP handshake, congestion window, TLS handshake, если HTTPS).  
- При большом количестве мелких файлов теряем много времени и overhead.  
* HTTP/2:  
- Всё сводится к одному (или очень небольшому числу) TCP-соединений, внутри которого одновременно идут все запросы/ответы (мультиплексирование).  
- Это уменьшает накладные расходы: меньше handshakes, быстрее старт (особенно заметно при HTTPS с TLS, где handshake сам по себе дорогой).  
- Заголовки сжимаются (HPACK), дополнительно снижая трафик.  
6. Шифрование  
* HTTP/1.1:  
- Может работать как в незашифрованном режиме (http://), так и «поверх» TLS (https://).  
- Но часто HTTP/1.1 встречается без шифрования (в случае http://).  
* HTTP/2:  
- По спецификации: может работать как с шифрованием (TLS), так и без.  
- На практике: большинство браузеров требуют TLS для HTTP/2. То есть если сайт говорит «я хочу HTTP/2», браузер ожидает защищённое соединение.  
- В результате почти весь HTTP/2 в интернете — это HTTPS.  
7. Совместимость  
* HTTP/1.1:  
- Долгое время был «де-факто» стандартом, поддерживается всеми устройствами и клиентами.  
* HTTP/2:  
- Широко поддерживается всеми современными браузерами и серверами (Nginx, Apache, IIS, Caddy, Cloudflare, CDN).  
- Автоматически «договариваются» о переходе на HTTP/2, если и клиент, и сервер его поддерживают. В противном случае fallback на HTTP/1.1.  
  
Также появляется HTTP/3, но пока он большинством систем не поддерживается. Из ключевых отличий - он строиться на базе протокола QUIC, который основан на UDP, когда как HTTP/1 и 2 основаны на TCP. Это значительно ускоряет передачу данных, т.к. TCP в случае потери одного пакета блокирует весь поток данных, пока не получит повторную передачу, а благодаря отдельным «потокам» внутри QUIC потеря пакетов не блокирует все данные сразу — это снижает задержки в сетях с высокими потерями или нестабильным соединением