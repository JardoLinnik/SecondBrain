Декоратор в Python — это функция, которая позволяет изменить или расширить поведение другой функции или метода, не изменяя их исходный код. Декоратор принимает функцию в качестве аргумента (оборачивает её), выполняет необходимые действия и возвращает новую или ту же функцию с измененным поведением. Обычно для декорации функций используется специальный синтаксис с @, чтобы облегчить чтение и использование декораторов.  
  
Декораторы полезны для:  
* Повторного использования кода — позволяют добавлять функциональность к нескольким функциям, избегая дублирования.  
* Разделения ответственности — позволяют выделить общие задачи, такие как логирование, проверка прав доступа или кеширование, в отдельные функции, что упрощает поддержку и улучшает читаемость кода.  
  
```  
from functools import wraps  
# Декоратор с аргументами (если аргументы не нужны, просто убрать внешнюю функу из определения)  
def log_execution(level="INFO"):  
def decorator(func):  
# wraps используется для сохранения метаданных оригинальной функции  
@wraps(func)  
def wrapper(*args, **kwargs):  
print(f"[{level}] Запуск функции '{func.__name__}' с аргументами {args} и {kwargs}")  
result = func(*args, **kwargs)  
print(f"[{level}] Завершение функции '{func.__name__}' с результатом {result}")  
return result  
return wrapper  
return decorator  
# Применяем декоратор с аргументом  
@log_execution(level="DEBUG")  
def add(a, b):  
"""Функция для сложения двух чисел."""  
return a + b  
# Используем декорированную функцию  
print(add(3, 5)) # Выводит логи и результат выполнения  
```  
  
ВАЖНО  
Функция log_execution называется фабрикой декораторов. Это способ создания параметризированных декораторов. Чтоб создать обычный декоратор, нужно убрать функцию log_execution и оставить внутренние две функции.  
Минусы декораторов:  
* Неинформативный стек вызовов при исключениях (исключение в декораторе, а не функе)  
* Потеря документации функции, надо использовать functools.wraps  
* Усложнение читаемости кода  
* Уменьшение производительности функции  
* Декоратор у метода не наследуется в классах