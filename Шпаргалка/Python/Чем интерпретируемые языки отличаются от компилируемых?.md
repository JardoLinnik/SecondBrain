Компилируемые языки (C, C++, Rust, Go и т.п.):  
  
* Процесс компиляции:  
- Исходный код (читаемый человеком) преобразуется в машинный код (инструкции для конкретного процессора).  
- Результат — это исполняемый файл (например, ELF на Linux, Mach-O на macOS, PE на Windows).  
* Производительность:  
- Как правило, выше, так как итоговый код исполняется непосредственно «железом», без промежуточных «прослоек».  
* Портируемость:  
- Нужно перекомпилировать программу под каждую целевую платформу (CPU+ОС). Исполняемый файл, скомпилированный для Linux x86, не запустится под Windows ARM без перекомпиляции.  
* Отладка и разработка:  
- Отладка может быть сложнее, т.к. изменения в коде требуют новой компиляции.  
- Зато компилятор может находить типовые ошибки ещё на этапе сборки, до запуска программы.  
  
Интерпретируемые языки (Python, Ruby, JavaScript и т.п.):  
  
* Процесс интерпретации:  
- Исходный код считывается и исполняется «на лету» (иногда со стадией байткода, как в Python, но всё равно есть «виртуальная машина»).  
- Нет явного шага компиляции в машинный код перед запуском (хотя за кулисами может быть JIT-компиляция).  
* Производительность:  
- Обычно ниже, чем у скомпилированных языков: каждая строчка/блок кода проходит через интерпретатор.  
- Тем не менее JIT-компиляторы могут сильно ускорять работу.  
* Портируемость:  
- Код зачастую кроссплатформенный без дополнительных манипуляций: достаточно, чтобы на целевой системе был установлен соответствующий интерпретатор.  
* Отладка и разработка:  
- Проще и быстрее править и тестировать код: изменения вступают в силу сразу (нет полного цикла компиляции).  
- Ошибки часто обнаруживаются уже во время выполнения, а не до запуска.