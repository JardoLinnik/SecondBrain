## Как бы я сказал на собеседовании

> Логи пишу **структурированно (JSON)**, с **корреляционными идентификаторами** и **контекстом запроса**.  
> В вебе (FastAPI) — middleware прокидывает `trace_id/request_id`, в воркерах (Kafka/RabbitMQ) — берем из заголовков/метаданных и продолжаем трейс.  
> Логи пишем в **stdout/stderr**, Kubernetes собирает их через **Fluent Bit/Fluentd** в **ELK/Loki**.  
> Маскируем ПДн/PCI-данные (карты, телефон, email), используем **уровни**, **семплинг дебага** и **алерты** в Grafana.  
> Ошибки дополнительно летят в **Sentry**. Конфиг — через `logging.config.dictConfig` либо `structlog`.

---

## Базовые принципы

- **JSON-логи** (machine-readable): легко парсить и строить дашборды.
    
- **Корреляция**: `trace_id`, `span_id`, `request_id`, `user_id`, `client_ip`, `service`, `version`.
    
- **Безопасность**: маскирование ПДн/секретов (152-ФЗ/PCI DSS), запрет сырых payload’ов.
    
- **Уровни**: `DEBUG` (семплом), `INFO` (основной поток), `WARNING/ERROR` (алерты).
    
- **В Kubernetes**: пишу в stdout → **Fluent Bit** → **Loki/ELK**; без локальных файлов и ротации.
    
- **Tracing**: OpenTelemetry (OTLP) + перенос `traceparent` через HTTP/Kafka/RabbitMQ.
    
- **SLO**: логирую ключевые метрики: latency, размер ответа, код статуса, бизнес-события.
    

---

## Схема поля лога (минимум)

```
{
  "ts": "2025-11-08T10:12:34.567Z",
  "level": "INFO",
  "service": "payments-api",
  "version": "1.14.3",
  "trace_id": "4f5b...a1",
  "span_id": "7c3...",
  "request_id": "req_...",
  "path": "/v1/payments",
  "method": "POST",
  "status": 200,
  "latency_ms": 42,
  "client_ip": "x.x.x.x",
  "msg": "payment authorized",
  "user_id": 12345,
  "order_id": "ab-42"
}

```

---

## FastAPI: middleware для трассировки и JSON-логов

```
# logging_conf.py
import logging, sys, json
from logging.config import dictConfig

class JsonFormatter(logging.Formatter):
    def format(self, record):
        payload = {
            "ts": self.formatTime(record, "%Y-%m-%dT%H:%M:%S"),
            "level": record.levelname,
            "service": "payments-api",
            "version": "1.14.3",
            "trace_id": getattr(record, "trace_id", None),
            "request_id": getattr(record, "request_id", None),
            "msg": record.getMessage(),
        }
        if record.exc_info:
            payload["exc_info"] = self.formatException(record.exc_info)
        return json.dumps(payload, ensure_ascii=False)

def setup_logging():
    dictConfig({
      "version": 1,
      "disable_existing_loggers": False,
      "handlers": {"stdout": {
        "class": "logging.StreamHandler", "stream": sys.stdout,
        "formatter": "json"
      }},
      "formatters": {"json": {"()": JsonFormatter}},
      "root": {"level": "INFO", "handlers": ["stdout"]},
    })

# app.py
import logging, uuid, time
from fastapi import FastAPI, Request
from logging_conf import setup_logging
setup_logging()
log = logging.getLogger(__name__)

app = FastAPI()

@app.middleware("http")
async def add_context(request: Request, call_next):
    start = time.perf_counter()
    request_id = request.headers.get("x-request-id") or str(uuid.uuid4())
    trace_id = request.headers.get("traceparent", request_id)
    # обработка
    response = await call_next(request)
    latency = int((time.perf_counter() - start) * 1000)
    extra = {"request_id": request_id, "trace_id": trace_id}
    log.info("http_request", extra=extra)
    log.info(
        "http_response",
        extra={**extra, "path": request.url.path, "method": request.method,
               "status": response.status_code, "latency_ms": latency}
    )
    response.headers["x-request-id"] = request_id
    return response

```

> В бою я добавляю **маскирование** чувствительных полей и выставляю `INFO` по умолчанию, `DEBUG` — только семплом или на фиче-флаг.

---

## Маскирование ПДн/PCI (пример)

```
import re
MASKS = [
    (re.compile(r"\b\d{16}\b"), "************####"),  # PAN (упростили для примера)
    (re.compile(r"\b\d{3}-\d{3}-\d{2}-\d{2}\b"), "***-***-**-**"),  # телефон/ИНН-подобное
    (re.compile(r"(?P<name>authorization|password|token)\":\"[^\"]+\"", re.I), r'\g<name>":"***"'),
]

def sanitize(s: str) -> str:
    for rx, repl in MASKS:
        s = rx.sub(repl, s)
    return s


```
Вызываю `sanitize()` перед логированием внешних payload’ов.

---

## Kafka/RabbitMQ консюмеры: продолжение trace и контекст

```
# Kafka consumer example (confluent-kafka)
headers = dict(msg.headers() or [])
trace_id = headers.get("trace_id") or headers.get("traceparent")
extra = {"trace_id": trace_id, "request_id": headers.get("request_id")}
log.info("kafka_message_received", extra=extra)

try:
    # обработка
    log.info("kafka_message_processed", extra=extra)
except Exception:
    log.exception("kafka_message_error", extra=extra)
    # ретраи/перекладка в DLQ

```

> В RabbitMQ — аналогично, берём `headers` из `BasicProperties`, добавляем в extra.

---

## В Kubernetes

- Пишу **только в stdout/stderr** → **Fluent Bit** забирает → **Loki/ELK**.
    
- В чартах Helm добавляю метки: `app`, `env`, `version`, чтобы фильтровать в Grafana.
    
- Ошибки (`ERROR`) триггерят алерты (через Loki/Promtail → Alertmanager).
    

---

## Ошибки и алертинг

- **Sentry** для стектрейсов и дупликации исключений.
    
- **Алерты** по шаблонам: резкий рост `ERROR`, `p95 latency`, 5xx на Ingress, Kafka consumer lag.
    
- **Sampling**: `DEBUG`—10% на канареечной версии или по `user_id`/`feature_flag`.
    

---

## База/внешние вызовы

- Логирую **SQL-операции** на уровне агрегатов (время, таблица, количество строк), без сырых параметров.
    
- Внешние HTTP — `method`, `url` (без query с ПДн), `status`, `latency_ms`, `retries`.
    

---

## Итог (1 фраза)

> Структурные JSON-логи с контекстом и трейсами, безопасное маскирование данных, stdout→EFK/Loki в Kubernetes, плюс Sentry и алерты — это даёт наблюдаемость сервиса и быстрый разбор инцидентов без риска утечки ПДн.