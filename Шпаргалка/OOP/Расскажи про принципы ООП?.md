Инкапсуляция — ограничивает доступ к внутренним данным и реализации объекта, предоставляя только необходимые для внешнего использования методы. Реализуется за счёт создания приватных полей и методов и работы с ними через публичные методы (сеттеры, геттеры и т. д.). Например, в сеттере можно добавить доп логику по проверке на дурака или дополнительную обработку полей.  
В Python реализуется за счёт приватных и защищённых методов, обозначающихся через __ и _ соответственно.  
Пример:  
Класс User хранит приватные атрибуты _password и предоставляет методы set_password и verify_password для безопасного управления паролями пользователей.  
  
```  
class User:  
def __init__(self, username):  
self.username = username  
self._password = None  
  
  
def set_password(self, password):  
self._password = hash_password(password)  
  
  
def verify_password(self, password):  
return self._password == hash_password(password)  
```  
  
Наследование — это способность объекта наследовать свойства и методы от другого объекта. Это помогает сократить повторение кода. В Python реализовано за счёт множественного наследования, где важен порядок наследования.  
Пример:  
Создадим базовый класс BaseRepository, который содержит общие методы для HTTP-запросов. Затем создадим подклассы UserRepository и ProductRepository, наследующиеся от BaseRepository и добавляющие специфичные методы для работы с пользователями и продуктами соответственно.  
  
```  
from abc import ABC, abstractmethod  
  
  
class BaseRepository(ABC):  
def __init__(self, base_url):  
self.base_url = base_url  
  
  
@abstractmethod  
def get(self, endpoint):  
pass  
  
  
@abstractmethod  
def post(self, endpoint, data):  
pass  
  
class UserRepository(BaseRepository):  
def get(self, endpoint):  
# Реализация GET-запроса для пользователей  
pass  
  
  
def post(self, endpoint, data):  
# Реализация POST-запроса для пользователей  
pass  
  
class ProductRepository(BaseRepository):  
def get(self, endpoint):  
# Реализация GET-запроса для продуктов  
pass  
  
  
def post(self, endpoint, data):  
# Реализация POST-запроса для продуктов  
pass  
```  
  
Полиморфизм - позволяет объектам использовать методы, которые были определены в их родительских классах, но при этом они могут иметь свою собственную реализацию этих методов. В Python можно перегружать операторы с помощью dunder-методов, переопределять методы родительских классов, реализовать работу метода или оператора одновременно с разными типами данных(классами) через if-else внутри метода.  
Пример:  
Создадим базовый класс Notification, который содержит метод send с общей логикой отправки уведомлений. Подклассы EmailNotification и SMSNotification переопределяют метод send, реализуя специфичные для них способы отправки уведомлений.  
  
```  
class Notification:  
def send(self, message):  
# Общая логика подготовки уведомления  
formatted_message = f""Уведомление: {message}""  
self._send(formatted_message)  
  
def _send(self, formatted_message):  
# Базовая реализация отправки (может быть переопределена)  
print(f""Отправка уведомления: {formatted_message}"")  
  
class EmailNotification(Notification):  
def _send(self, formatted_message):  
# Специфичная реализация отправки по Email  
print(f""Отправка Email: {formatted_message}"")  
  
class SMSNotification(Notification):  
def _send(self, formatted_message):  
# Специфичная реализация отправки по SMS  
print(f""Отправка SMS: {formatted_message}"")  
```  
  
Абстракция — позволяет скрывать сложные детали реализации и предоставлять только необходимый функционал через простой интерфейс. Абстракция фокусируется на том, что объект делает, а не как он это делает. В Python реализована за счёт класса ABC и декоратора @abstractmethod из модуля abc.  
В качестве примера подойдёт любой из приведённых выше.