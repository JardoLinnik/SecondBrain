Паттерн «Наблюдатель» (Observer) решает задачу автоматического уведомления заинтересованных объектов (наблюдателей) об изменениях в другом объекте (субъекте/издателе).  
  
Как это выглядит на практике:  
* У нас есть «издатель» (subject), который «изменяется».  
* Есть «наблюдатели» (observers), которые хотят узнавать об изменениях издателя.  
* Когда в издателе что-то меняется, он оповещает всех подписанных наблюдателей (например, вызывает у них метод update() или аналогичный).  
  
Достоинства паттерна:  
* Ослабленная связанность: издатель не зависит от конкретных классов подписчиков и знает только, что у них есть метод update(). Это упрощает поддержание и расширение кода.  
* Гибкое расширение: можно легко добавить новых наблюдателей или удалить существующих, не меняя код издателя.  
* Удобство подписки/отписки: наблюдатель может самостоятельно «подключаться» (attach) к издателю и «отключаться» (detach) от него, когда это необходимо.  
* Реактивный подход: позволяет в реальном времени реагировать на события, распространять уведомления всем заинтересованным сервисам и модулям, что особенно полезно в высоконагруженных системах.  
  
Пример:  
  
Сервис оплаты — чтобы списать деньги.  
Сервис уведомлений — чтобы отправить письмо или СМС с подтверждением заказа.  
Сервис доставки — чтобы начать подготовку и отгрузку товара.  
Сервис аналитики — чтобы зафиксировать факт покупки и проанализировать данные (например, для рекомендаций).  
  
Чтобы не «зашивать» логику оповещения всех этих сервисов прямо в код метода оформления заказа, удобно использовать паттерн «Наблюдатель». Тогда при появлении нового заказа «издатель» (OrderManager) рассылает всем «наблюдателям» (PaymentService, NotificationService, ShippingService и т.д.) уведомление о событии.  
  
```  
class OrderManager:  
"""Издатель (Subject) — оформляет заказ и рассылает уведомления."""  
def __init__(self):  
self.observers = []  
  
def attach(self, observer):  
self.observers.append(observer)  
  
def detach(self, observer):  
self.observers.remove(observer)  
  
def notify(self, order):  
for observer in self.observers:  
observer.update(order)  
  
def create_order(self, user_id, items):  
# Логика создания заказа в БД  
order = {"user_id": user_id, "items": items, "order_id": 123}  
print(f"[OrderManager] Заказ создан: {order}")  
  
# После создания заказа уведомляем все подписанные сервисы  
self.notify(order)  
  
  
class PaymentService:  
"""Наблюдатель (Observer) для оплаты."""  
def update(self, order):  
print(f"[PaymentService] Оплата заказа #{order['order_id']} запущена.")  
  
  
class NotificationService:  
"""Наблюдатель (Observer) для отправки уведомлений."""  
def update(self, order):  
print(f"[NotificationService] Уведомление о заказе #{order['order_id']} отправлено пользователю.")  
  
  
class ShippingService:  
"""Наблюдатель (Observer) для доставки."""  
def update(self, order):  
print(f"[ShippingService] Заказ #{order['order_id']} взят в обработку на складе.")  
  
  
# Инициализация  
order_manager = OrderManager()  
  
payment_service = PaymentService()  
notification_service = NotificationService()  
shipping_service = ShippingService()  
  
# Подписываем сервисы на события создания заказа  
order_manager.attach(payment_service)  
order_manager.attach(notification_service)  
order_manager.attach(shipping_service)  
  
# Создаём заказ (издатель сам разошлёт обновления всем подписанным наблюдателям)  
order_manager.create_order(user_id=42, items=["Laptop", "Mouse"])  
```c