Паттерн «Стратегия» (Strategy) — это поведенческий шаблон проектирования, который позволяет выбрать одну из нескольких возможных «стратегий» поведения объекта во время выполнения программы. Смысл в том, чтобы вынести схожий функционал в отдельные классы (каждый класс реализует свою стратегию), а не «зашивать» различную логику внутрь одного большого класса с кучей if-else.  
  
Структура паттерна  
* Интерфейс (Strategy). Определяет метод (или методы), которые должны быть реализованы в конкретных стратегиях.  
* Конкретные стратегии (ConcreteStrategyA, ConcreteStrategyB и т.д.). Реализуют разные варианты алгоритма, соответствуя интерфейсу «Стратегии».  
* Контекст (Context). Хранит ссылку на одну из стратегий и вызывает нужные методы в нужное время. Контекст не отвечает за реализацию алгоритма — он лишь выбирает, какую стратегию использовать, и вызывает её.  
  
Основные плюсы  
* Принцип единственной ответственности: каждая стратегия отвечает за свой алгоритм.  
* Принцип открытости/закрытости: чтобы добавить новый способ доставки, пишем новую стратегию, не трогая старый код.  
* Упрощённый код контекста: он не знает деталей реализации разных стратегий, только вызывает нужный метод.  
  
Пример:  
  
```  
from abc import ABC, abstractmethod  
  
# 1. Интерфейс (абстрактный базовый класс) Стратегии  
class DeliveryStrategy(ABC):  
@abstractmethod  
def calculate_cost(self, weight: float, distance: float) -> float:  
pass  
  
# 2. Конкретные стратегии  
  
class PostStrategy(DeliveryStrategy):  
def calculate_cost(self, weight: float, distance: float) -> float:  
# Допустим, у почты свои расценки  
return weight * 0.5 + distance * 0.1  
  
  
class CourierStrategy(DeliveryStrategy):  
def calculate_cost(self, weight: float, distance: float) -> float:  
# У курьера другая логика  
return weight * 1.0 + distance * 0.2  
  
  
class PickupStrategy(DeliveryStrategy):  
def calculate_cost(self, weight: float, distance: float) -> float:  
# Самовывоз — предположим, бесплатно  
return 0.0  
  
# 3. Контекст  
class DeliveryService:  
def __init__(self, strategy: DeliveryStrategy):  
self._strategy = strategy  
  
def set_strategy(self, strategy: DeliveryStrategy):  
self._strategy = strategy  
  
def calculate_delivery_price(self, weight: float, distance: float) -> float:  
return self._strategy.calculate_cost(weight, distance)  
  
# Пример использования  
if __name__ == ""__main__"":  
# Создаём сервис доставки с начальной стратегией ""Почта""  
service = DeliveryService(PostStrategy())  
cost = service.calculate_delivery_price(weight=2.5, distance=50)  
print(""Post cost:"", cost)  
  
# Меняем стратегию на ""Курьер""  
service.set_strategy(CourierStrategy())  
cost = service.calculate_delivery_price(weight=2.5, distance=50)  
print(""Courier cost:"", cost)  
  
# Меняем стратегию на ""Самовывоз""  
service.set_strategy(PickupStrategy())  
cost = service.calculate_delivery_price(weight=2.5, distance=50)  
print(""Pickup cost:"", cost)  
```