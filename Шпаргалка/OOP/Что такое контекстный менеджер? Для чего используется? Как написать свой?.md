Контекстный менеджер — это механизм, который позволяет автоматически управлять ресурсами, такими как файлы, сетевые соединения, блокировки, транзакции и т.д. Он используется для того, чтобы гарантировать выполнение кода до и после некоторой операции, например, для безопасного открытия и закрытия файла. Контекстный менеджер создаёт «контекст», в котором выполняются операции, и обеспечивает выполнение финализирующих действий, таких как закрытие файла или коммит, даже в случае исключений.  
  
Как работает контекстный менеджер  
Контекстные менеджеры реализуют два специальных метода:  
__enter__() — выполняется при входе в блок with. Этот метод обычно инициализирует или открывает ресурс и возвращает объект, который будет использован внутри блока with.  
__exit__(exc_type, exc_value, traceback) — выполняется при выходе из блока with. Этот метод освобождает ресурс, например, закрывает файл. Если в блоке with произошло исключение, его параметры передаются в этот метод, чтобы его можно было обработать.  
Может быть асинхронным, тогда перед with пишется async.  
  
Как написать свой контекстный менеджер  
Свой контекстный менеджер можно написать, определив класс с методами __enter__ и __exit__.  
  
```  
class FileManager:  
def __init__(self, filename, mode):  
self.filename = filename  
self.mode = mode  
self.file = None  
def __enter__(self):  
# Открываем файл при входе в блок with  
self.file = open(self.filename, self.mode)  
return self.file # Возвращаем объект файла для использования в блоке with  
def __exit__(self, exc_type, exc_value, traceback):  
# Закрываем файл при выходе из блока with  
if self.file:  
self.file.close()  
# Использование нашего контекстного менеджера  
with FileManager("file.txt", "w") as f:  
f.write("Hello, World!")  
```  
  
Python предоставляет модуль contextlib, который упрощает создание контекстных менеджеров. С помощью декоратора @contextmanager можно создать контекстный менеджер без необходимости создавать класс с методами __enter__ и __exit__.  
  
```  
from contextlib import contextmanager  
@contextmanager  
def open_file(filename, mode):  
f = open(filename, mode)  
try:  
yield f # Передаем управление в блок with  
finally:  
f.close() # Гарантированно закрываем файл при выходе  
# Использование  
with open_file("file.txt", "w") as f:  
f.write("Hello, World!")  
```