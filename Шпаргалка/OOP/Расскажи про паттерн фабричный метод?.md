Паттерн «Фабричный метод» (Factory Method) относится к порождающим паттернам проектирования и решает задачу создания объектов. Он предоставляет интерфейс для создания объектов, но оставляет выбор конкретного класса для порождаемых объектов наследникам (подклассам).  
  
Общая структура  
* Product (Интерфейс или Абстрактный класс продукта) — общий интерфейс создаваемого объекта.  
* ConcreteProduct (Конкретные продукты) — различные варианты объектов, реализующие интерфейс Product.  
* Creator (Создатель) — базовый класс или интерфейс, который содержит фабричный метод createProduct().  
* ConcreteCreator (Конкретные создатели) — подклассы Creator, которые переопределяют фабричный метод, указывая, какой конкретный продукт создавать.  
  
Пример реализации:  
  
В нашем приложении есть различные каналы оповещений для пользователей:  
  
* Email  
* SMS  
* Push-уведомления  
* Логика отправки в каждом случае своя:  
  
Электронная почта требует установления SMTP-соединения и формата письма.  
SMS требуют интеграции с внешним провайдером.  
Push — отдельный сервис или API.  
Чтобы не захламлять код кучей if-else при выборе канала, используем Фабричный метод:  
  
Базовый класс (Creator) будет у нас NotificationFactory, имеющий фабричный метод create_notification().  
Конкретные фабрики (ConcreteCreators) для каждого канала будут переопределять этот метод.  
Общий интерфейс (Product) — Notification, а конкретные классы (ConcreteProducts) — EmailNotification, SMSNotification, PushNotification.  
  
Таким образом код, который «хочет» отправить уведомление, будет использовать фабрику, но не будет «заморачиваться», как именно создаётся уведомление.  
  
Код:  
  
```  
from abc import ABC, abstractmethod  
  
class Notification(ABC):  
"""Абстрактный класс для всех уведомлений."""  
  
@abstractmethod  
def send(self, to: str, message: str) -> None:  
"""Метод отправки уведомления."""  
pass  
  
class EmailNotification(Notification):  
"""Уведомление по Email."""  
  
def send(self, to: str, message: str) -> None:  
# Здесь могла быть логика SMTP, формирование письма и т.д.  
print(f"[Email] Отправляем письмо на {to}: {message}")  
  
  
class SMSNotification(Notification):  
"""Уведомление по SMS."""  
  
def send(self, to: str, message: str) -> None:  
# Здесь код интеграции с SMS-шлюзом  
print(f"[SMS] Отправляем SMS на {to}: {message}")  
  
  
class PushNotification(Notification):  
"""Push-уведомление."""  
  
def send(self, to: str, message: str) -> None:  
# Здесь обращение к сервису пуш-уведомлений (Firebase, OneSignal и т.п.)  
print(f"[Push] Отправляем PUSH для {to}: {message}")  
  
class NotificationFactory(ABC):  
"""Абстрактная фабрика уведомлений."""  
  
@abstractmethod  
def create_notification(self) -> Notification:  
"""Фабричный метод: возвращает объект Notification."""  
pass  
  
def process_and_send(self, to: str, message: str) -> None:  
"""  
Общий метод, который может что-то готовить,  
а затем использовать созданное уведомление.  
"""  
notification = self.create_notification()  
# Допустим, здесь какая-то подготовка,  
# логирование, проверка и т.д.  
notification.send(to, message)  
  
class EmailNotificationFactory(NotificationFactory):  
"""Фабрика, создающая Email-уведомления."""  
  
def create_notification(self) -> Notification:  
return EmailNotification()  
  
  
class SMSNotificationFactory(NotificationFactory):  
"""Фабрика, создающая SMS-уведомления."""  
  
def create_notification(self) -> Notification:  
return SMSNotification()  
  
  
class PushNotificationFactory(NotificationFactory):  
"""Фабрика, создающая Push-уведомления."""  
  
def create_notification(self) -> Notification:  
return PushNotification()  
  
def get_notification_factory(channel: str) -> NotificationFactory:  
"""  
Пример «выбора» нужной фабрики по названию канала.  
Может быть конфигурация из БД, из .env, из настроек...  
"""  
if channel == "email":  
return EmailNotificationFactory()  
elif channel == "sms":  
return SMSNotificationFactory()  
elif channel == "push":  
return PushNotificationFactory()  
else:  
raise ValueError(f"Unknown notification channel: {channel}")  
  
  
# Допустим, где-то в коде бэкенда:  
def send_user_notification(user_id: int, message: str):  
"""  
Функция, которая отправляет уведомление пользователю,  
не заботясь о конкретном канале.  
"""  
# Предположим, мы достали из базы данных или настроек,  
# что пользователь предпочитает SMS  
user_channel = "sms"  
user_contact = "79001234567" # Например, телефон  
  
# Получаем фабрику по нужному каналу  
factory = get_notification_factory(user_channel)  
  
# Отправляем сообщение  
factory.process_and_send(to=user_contact, message=message)  
  
```  
В чём польза такого решения?  
* Удобное расширение: если нам понадобится новый тип уведомлений (например, Telegram-уведомления), мы просто добавим новый класс TelegramNotification и новую фабрику TelegramNotificationFactory. Мы не меняем код других фабрик и минимально затрагиваем общий код.  
* Отделение логики создания объектов (конкретных уведомлений) от остальной бизнес-логики бэкенда.  
* Чистый код: вместо бесконечного if-elif-else в одном месте, у нас упорядоченный набор фабрик, каждая отвечает только за свой вариант.