Генератор - это особый вид итератора, который создается с помощью функцию, которая содержит одну или несколько инструкций yield  
  
Генераторы упрощают создание итераторов, позволяя создавать последовательности данных на лету, без необходимости заранее определять и хранить всю последовательность в памяти.  
  
example_i = [i for i in range(3)] # Iterator: [0, 1, 2]  
example_g = (i for i in range(3)) # Generator: <generator object <genexpr> at 0x10099bd60>  
  
Отличительные особенности генератора:  
**Использование `yield`**  
* Вместо обычного `return`, который завершает выполнение функции, `yield` приостанавливает выполнение функции и возвращает текущее значение. Когда генератор возобновляется (например, вызовом метода `__next__()`), выполнение продолжается с точки, где оно было приостановлено.  
  
2. **Сохранение состояния:**  
- Генераторы сохраняют локальное состояние (значения переменных и точку выполнения) между вызовами, что позволяет им эффективно управлять последовательностями данных и выполнять сложные вычисления.  
  
- **Ленивое вычисление:**  
- Генераторы вычисляют значения по мере необходимости, что делает их особенно полезными для работы с большими или бесконечными последовательностями данных. Они не загружают все данные в память, а генерируют их по одному элементу.  
  
Особенности:  
* Автоматическая реализация __iter__() и __next__()  
* Генератор можно использовать только 1 раз  
def gen():  
yield 1  
yield 2  
  
[print(f"First Iteration {i}") for i in gen()]  
[print(f"Second Iteration {i}") for i in gen()]  
  
# First Iteration 1  
# First Iteration 2  
# Second Iteration 1  
# Second Iteration 2  
* Бесконечные последовательности.  
def fib():  
a, b = 0, 1  
while True:  
yield a  
a,b = b, a + b  
  
f = fib()  
for _ in range(10):  
print(next(f))  
* Широко используются с потоками данных ( большие файлы, сложные последовательные данные, реализация ленивых вычислений )