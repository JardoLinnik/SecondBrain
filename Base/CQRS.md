CQRS - это **архитектурный принцип** разделение ответственности : команды (изменяют состояние) и запросы/чтение (возвращают состояние) - каждая часть оптимизированна под свою задачу.

- Commands (команды)
	- Операции, которые меняют состояние.
	- `Reverse(item,qty), Confirm(oredr), Release(order)`. Команды обычно идет на запись.

- Queries (запросы)
	- Операции, которые читуют состояние.
	- `GetAvailable(item, location)`. Запросы не должны менять состояние.


-  Чтение и запись имеют разные требования. Чтение — быстрое, часто с фильтрами и поиском. Запись — консистентность и бизнес-логика. Разделив их, мы можем оптимизировать каждую часть отдельно (например, read-model в ElasticSearch, write-model в Postgres).

- Важная деталь: при CQRS часто применяют **проекции/read-models** — специально подготовленные структуры данных для быстрых ответов, которые обновляются по событиям (event handlers).

- Применяют когда
	- - У системы много сложных инвариантов/правил на запись **и** нагрузка/вариативность запросов на чтение высокая.
    
	- Нужны быстрые UX-запросы (фильтры, списки, отчеты) без «тяжелых» джоинов.
    
	- Важно масштабировать чтение и запись по-разному.


**Проблема**:

**Пример**:

**Доп. ссылки:** [[Архитектура backend]]

**Tags**: #Backend #IT #АрхитектуаПриложения 