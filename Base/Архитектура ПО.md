- В чём плюсы и минусы монолитного подхода? В каких ситуациях его использовать?
	- Плюсы:  
	* Простота разработки: Вся функциональность находится в одном кодовом базе, что облегчает разработку.  
	* Единый деплоймент: Для развертывания требуется лишь один образ приложения, что упрощает процесс деплоя.  
	* Высокая производительность: Внутренние вызовы методов происходят быстрее, так как не требуют сетевого взаимодействия.  
	* Упрощённое управление: Администрирование и мониторинг системы осуществляются централизованно.  
	* Меньше накладные расходы на обслуживание  
	* Легкое управление транзакциями и поддержка целостности данных, т.к. у проекта обычно одна БД.  
  
	Минусы:  
	* Ограниченная масштабируемость: Трудно масштабировать отдельные компоненты приложения; масштабируется вся система целиком.  
	* Сложность поддержки: По мере роста кодовой базы поддержка и обновление приложения становятся всё более трудоёмкими.  
	* Риски при обновлении: Изменения в одной части приложения требуют повторного деплоймента всего приложения, что увеличивает риск сбоев.  
	* Монотонность технологического стека: Трудно внедрять новые технологии или языки программирования в отдельных частях приложения.  
  
	Хорошо подходит для мелких приложений, приложений, где все функции взаимодействуют с единой сильно связанной моделью данных, ситуаций, когда нужно быстро написать MVP, когда мало денег на инфраструктуру, и приложений с маленьким временем задержки.
- В чём плюсы и минусы микросервисного подхода? В каких ситуациях его использовать?
	Плюсы:  
	* Масштабируемость: Каждый сервис можно масштабировать независимо в соответствии с его нагрузкой.  
	* Гибкость в выборе технологий: Разные сервисы могут быть написаны на разных языках и использовать разные технологии, оптимальные для их задач.  
	* Гибкость в разработке: Разные команды могут одновременно разрабатывать разные сервисы и им проще будет погружать новых сотрудников в проект, т.к. код микросервиса легче понять, чем код монолита, т.к. он разделен на четкие задачи  
	* Улучшенная отказоустойчивость и повышенная доступность: Сбой одного сервиса не приводит к падению всей системы, что повышает общую надежность.  
	* Независимый деплоймент: Обновление одного сервиса не требует перезапуска всей системы, что ускоряет процесс внедрения изменений.  
	  
	Минусы:  
	* Сложность разработки и синхронизации: Разработка распределенной системы требует учета множества факторов, таких как сетевые взаимодействия, согласованность данных и т.д.  
	* Затраты на инфраструктуру: Требуется более сложная инфраструктура для оркестрации сервисов, управления конфигурациями и мониторинга.  
	* Повышенное время задержки: Взаимодействие между сервисами происходит по сети, что может привести к задержкам и требует оптимизации.  
	* Сложность тестирования: Тестирование распределенных систем сложнее из-за необходимости учитывать взаимодействия между сервисами.  
	  
	Подходит для всего остального после ситуаций, когда лучше подходит монолит
- Что такое монолитное приложение?
	- Монолитное приложение — это программное обеспечение, в котором все компоненты и функциональные модули объединены в единую, неделимую кодовую базу. В такой архитектуре все части приложения тесно связаны и работают как одно целое.
- Что такое микросервис?
	- Микросервис — это небольшое, независимое приложение, которое выполняет одну конкретную функцию в составе более крупной системы. Каждое такое приложение представляет собой отдельный сервис со своим кодом, базой данных и часто своим стеком технологий. Микросервисы взаимодействуют друг с другом через стандартизированные интерфейсы, например, REST API.
- Что такое Saga?
	Saga — это архитектурный шаблон, используемый для управления распределёнными транзакциями в микросервисных архитектурах. Он помогает координировать набор операций, которые должны выполняться последовательно, чтобы обеспечить согласованность данных в случае отказов или ошибок. (реализуется через сообщения в брокере)  
	  
	Saga делится на два типа:  
	Оркестрированная Saga — когда центральный оркестратор управляет всеми шагами транзакции, отправляя команды каждому из сервисов и получая их отклик.  
	Хореографированная Saga — когда сервисы взаимодействуют напрямую друг с другом через события. В случае успеха или ошибки каждый сервис сам решает, как реагировать на полученное событие и как выполнять свои операции.  
	  
	Отличия от 2pc (two-phase-commit):  
	* Механизм согласования и управления:  
	- Saga работает по принципу последовательных действий и компенсаций. Каждый шаг (операция) в транзакции выполняется независимо, а в случае ошибки или сбоя предыдущие шаги компенсируются откатами.  
	- 2PC использует жёсткий централизованный подход для согласования всех участников. Координатор транзакции сначала собирает от всех участников подтверждение готовности (1-я фаза), а затем завершает транзакцию (2-я фаза) только если все участники согласны. Если кто-то не готов, происходит общий откат.  
	* Терпимость к сбоям:  
	- Saga лучше адаптирована для отказоустойчивых и распределённых систем. В случае сбоя отдельного шага происходит компенсация, а остальные участники продолжают работать. Это делает её более гибкой для микросервисных архитектур.  
	- 2PC неустойчива к сбоям, так как центральный координатор представляет собой "точку отказа" (Single Point of Failure). Если координатор выходит из строя или один из участников отказывает, вся транзакция остаётся "подвешенной".  
	* Масштабируемость:  
	- Saga хорошо масштабируется в микросервисной архитектуре, так как не требует блокировок ресурсов. Каждый сервис работает независимо и обрабатывает шаги асинхронно.  
	- 2PC плохо масштабируется в крупных распределённых системах из-за необходимости согласования и блокировки ресурсов для всех участников, что замедляет выполнение.  
	* Использование и применимость:  
	- Saga используется для долгоживущих, распределённых транзакций, которые могут быть откатаны через компенсационные действия (например, бронирование авиабилетов, где шаги могут отменяться).  
	- 2PC подходит для случаев, когда нужна строгая согласованность и транзакции завершаются в течение короткого времени (например, банковские переводы внутри одной системы), но менее практична для распределённых микросервисных архитектур.  
	Итог: Saga обеспечивает асинхронную, менее жёсткую согласованность с компенсационными действиями, а 2PC — строгую синхронную согласованность, жертвуя гибкостью и масштабируемостью.  
  
	https://ibb.co/FWBDcxZ
- Что такое API Gateway и Reverse Proxy?
	API Gateway/Reverse Proxy — это компонент, который действует как единая точка входа для всех клиентских запросов к микросервисной архитектуре. Он выполняет множество функций, упрощая взаимодействие между клиентами и набором микросервисов, обеспечивая их безопасность, маршрутизацию и согласованность.  
	  
	Основные задачи API Gateway включают:  
	* Аутентификация и авторизация: API Gateway может проверять подлинность клиента и его права доступа перед тем, как разрешить запрос, что упрощает управление безопасностью в распределённой системе.  
	* Агрегация и трансформация данных: API Gateway может объединять данные от разных микросервисов в один ответ, что снижает количество запросов, необходимых клиенту, и повышает производительность.  
	* Мониторинг и логирование: API Gateway собирает информацию о запросах, ошибках и трафике, что помогает в мониторинге и улучшении системы.  
	  
	Основные задачи Reverse Proxy включают:  
	* Маршрутизация запросов: Получает запрос от клиента и перенаправляет его к нужному микросервису. Это позволяет скрывать внутреннюю структуру сервисов и делать их архитектуру более гибкой.  
	* Балансировка нагрузки: между репликами сервисов через Ingress Nginx в k8s  
	* Кэширование: Может кэшировать часто запрашиваемые данные, что снижает нагрузку на микросервисы и улучшает время отклика.
* Какие паттерны микросервисной архитектуры ты знаешь?
	Saga, Api Gateway, Reverse proxy, Сircuit Breaker, Health Check, Шина данных и др. ( https://cloud.vk.com/blog/26-osnovnyh-patternov-mikroservisnoj-razrabotki/ )
- Что такое circuit breaker?
	Circuit Breaker (переключатель цепи) — это паттерн, используемый для повышения устойчивости распределённых систем и предотвращения цепных отказов. Он помогает контролировать и изолировать неисправные компоненты или сервисы, чтобы сбой в одном из них не привёл к сбоям в других частях системы. Работает аналогично “Выбитым пробкам” дома.  
	  
	Как работает Circuit Breaker:  
	Circuit Breaker можно представить как переключатель с тремя основными состояниями:  
	* Closed (Замкнут): В нормальном состоянии Circuit Breaker пропускает запросы. Если возникают ошибки (например, сервис не отвечает), он начинает фиксировать их количество.  
	* Open (Открыт): Если количество ошибок превышает определённый порог за заданный период, Circuit Breaker "размыкается", блокируя дальнейшие запросы к этому сервису на некоторое время. В это время запросы сразу отклоняются или перенаправляются на резервный ресурс, не достигая неисправного сервиса.  
	* Half-Open (Полуоткрыт): После тайм-аута Circuit Breaker переходит в режим "полуоткрытого" состояния и отправляет несколько тестовых запросов к сервису. Если тестовые запросы успешны, он возвращается в "замкнутое" состояние, и сервис считается восстановленным. Если тестовые запросы продолжают завершаться с ошибками, Circuit Breaker снова переходит в "открытое" состояние.  
	  
	Применение:  
	Circuit Breaker защищает систему от чрезмерной нагрузки на неисправные или медленно работающие сервисы.  
	Помогает избежать истощения ресурсов и деградации системы, повышая её отказоустойчивость.  
	Используется в микросервисных архитектурах, когда один сервис зависит от других, чтобы предотвратить лавинообразный сбой.  
	  
	Пример:  
	Представьте, что у вас есть сервис, обращающийся к базе данных, которая внезапно начинает тормозить. Если запросы продолжают посылаться, это может привести к истощению ресурсов и сбою других сервисов. Circuit Breaker размыкает цепь, предотвращая запросы к базе данных, пока она не восстановится, и защищает остальную систему 
	от сбоев. Также Circuit Breaker может использоваться для прекращения обращения к внешним системам.
- Что такое DDD?
	DDD (Domain-Driven Design) — это подход к разработке программного обеспечения, который фокусируется на модели предметной области (domain), то есть на бизнес-логике и правилах, которые она описывает. Основная идея DDD состоит в том, чтобы создать чёткую и согласованную модель предметной области, которая отражает реальные потребности бизнеса и облегчает понимание системы для всех участников: разработчиков, аналитиков и представителей бизнеса.  
	  
	Основные концепции DDD:  
	* Domain (Предметная область): Основная сфера деятельности бизнеса, то, что разрабатывается и совершенствуется. Это может быть, например, банковская система или система бронирования авиабилетов.  
	* Ubiquitous Language (Общий язык): В DDD особое внимание уделяется созданию общего языка, которым пользуются и технические, и бизнес-специалисты. Этот язык помогает всем участникам проекта лучше понимать предметную область и избегать недопониманий.  
	* Bounded Context (Ограниченный контекст): Комплексный бизнес обычно состоит из множества частей (контекстов), которые могут иметь собственные правила и термины. Bounded Context обозначает границы, в которых конкретные термины и правила применяются. Разделение на контексты помогает разрабатывать разные части системы независимо друг от друга.(например, в интернет магазине есть контексты каталога продуктов, платежей, учёта товаров на складе, базы сотрудников)  
	* Entities и Value Objects: Entities — это объекты с уникальными идентификаторами, которые изменяются со временем (например, заказ клиента). Value Objects — это объекты без уникальных идентификаторов, которые определяются только своими атрибутами (например, адрес или валюта).  
	* Aggregates (Агрегаты): Агрегаты — шаблон для работы с группой связанных объектов сущностей из конкретной предметной области, которые считаются одной единицей для обработки данных и бизнес-логики. Например, при оформлении заказа агрегатор генерирует объекты сущностей оплата заказа, доставка заказа, позиция заказа.  
	* Repositories и Services: Repositories обеспечивают доступ к данным агрегатов, а Services содержат логику, которая не относится к конкретным сущностям, но важна для предметной области.  
	  
	Зачем использовать DDD:  
	* DDD помогает проектировать сложные системы с учётом бизнес-требований, обеспечивая ясность и структурированность.  
	* Оно способствует разделению ответственности в коде и позволяет создавать систему, которая легко адаптируется к изменениям в бизнес-логике.  
	* Использование DDD улучшает взаимодействие между разработчиками и бизнес-экспертами, поскольку общая модель предметной области и язык упрощают коммуникацию.
* Что такое MVC?
	MVC (Model-View-Controller)  
	  
	Компоненты:  
	* Model (Модель): Управляет данными и бизнес-логикой приложения.  
	* View (Представление): Отвечает за отображение данных пользователю.  
	* Controller (Контроллер): Обрабатывает ввод пользователя, взаимодействует с моделью и определяет, какое представление отобразить.  
	  
	Особенности:  
	* View и Model не взаимодействуют напрямую.  
	* Controller служит посредником между View и Model.  
	* Часто используется в веб-разработке (например, Django, Ruby on Rails).  
	  
	Схема взаимодействия:  
	[User] → [Controller] → [Model]  
	↘  
	[View]  
	  
	Пример потока данных:  
	1. Пользователь отправляет запрос.  
	2. Controller обрабатывает запрос, взаимодействует с Model для получения данных.  
	3. Controller передает данные в View.  
	4. View отображает данные пользователю.
- Расскажи про Serverless-архитектуру?
	Serverless-архитектура — это облачная модель, при которой разработчики запускают свои приложения или функции, не управляя серверами напрямую. В serverless-подходе облачный провайдер автоматически управляет инфраструктурой, масштабированием и распределением ресурсов, позволяя разработчикам сосредоточиться на бизнес-логике, а не на серверной инфраструктуре.  
	  
	Основные принципы Serverless-архитектуры:  
	* Функции как сервис (FaaS, Function as a Service):  
	- Код приложения разбивается на отдельные функции, которые выполняют конкретные задачи. Эти функции запускаются только тогда, когда это необходимо (например, в ответ на событие), и работают короткое время, чтобы выполнить определённую операцию.  
	- Пример: AWS Lambda, Google Cloud Functions, Azure Functions.  
	* Событийно-ориентированная модель:  
	- Serverless-архитектура построена вокруг событий. Функции вызываются в ответ на различные триггеры, такие как HTTP-запросы, изменения в базе данных, загрузка файлов и т.д.  
	- Это позволяет создать системы, которые работают асинхронно и реагируют на определённые действия или изменения состояния.  
	* Автоматическое масштабирование:  
	- Облачный провайдер автоматически масштабирует функции в зависимости от нагрузки. Если возникает всплеск запросов, провайдер динамически запускает больше экземпляров функции; если запросов мало, количество экземпляров уменьшается до минимума.  
	* Оплата за фактическое использование:  
	- В отличие от традиционных серверных подходов, где вы платите за серверы независимо от их загрузки, в serverless платите только за фактическое время выполнения функций и количество запросов. Это делает serverless особенно экономичным для приложений с переменной или непредсказуемой нагрузкой.  
	  
	Преимущества Serverless-архитектуры:  
	* Снижение операционной нагрузки: не нужно беспокоиться об инфраструктуре.  
	* Быстрое развертывание и разработка: функции можно разрабатывать, развертывать и обновлять по отдельности и на разных языках, что упрощает разработку и внедрение изменений. Но стек технологий ограничен провайдером.  
	* Экономия средств: оплата за фактическое использование позволяет минимизировать расходы при нерегулярной нагрузке.  
	* Масштабируемость и устойчивость: автоматическое масштабирование и управление ресурсами позволяют выдерживать переменную нагрузку и обеспечивают отказоустойчивость.  
	  
	Ограничения Serverless-архитектуры:  
	* Холодный старт: при первом запуске функции после простоя может наблюдаться задержка (холодный старт), что может не подойти для приложений с жёсткими требованиями к задержке.  
	* Ограничение по времени выполнения: многие FaaS-платформы накладывают лимиты на максимальное время выполнения функций, что может быть ограничением для длительных операций.  
	* Ограниченные возможности отладки и мониторинга: сложнее отлаживать распределённые функции и управлять логами.  
	* Сравнение с монолитом и микросервисами:  
	* Сложность разработки и управления близка к микросервисам, что сложнее, чем монолит.  
	  
	Таким образом, Serverless можно использовать там, где приходится не слишком часто, но интенсивно обрабатывать большое количество запросов. В этом случае запускать несколько функций на 15 минут выгоднее, чем все время держать виртуальную машину или сервер.
-  Что такое lambda-функция?
	Lambda-функция — это кусок кода, который выполняется без необходимости управлять серверной инфраструктурой. Он запускается в ответ на события (например, HTTP-запросы, изменения в базе данных, загрузка файлов) и выполняет конкретную задачу, после чего автоматически завершается.
- Что такое lambda-computing?
	Lambda-computing — это концепция вычислений, основанная на модели serverless, при которой код выполняется в ответ на события, а инфраструктура автоматически управляется и масштабируется облачным провайдером. Lambda-computing позволяет запускать функции (небольшие фрагменты кода) без необходимости вручную настраивать или поддерживать серверы, что даёт разработчикам гибкость и экономичность.
- Какие паттерны отказоустойчивости ты знаешь?
	* Retry - повтор запросов с определённым интервалом и определённое кол-во раз  
	* Идемпотентность - добавление специального ключа, благодаря которому при ретраях не дублируются действия  
	* Deadline propagation - Идея паттерна в том, что клиент в запросе к серверу передаёт значение тайм-аута. Сервер в процессе обработки запроса регулярно проверяет: не истёк ли тайм-аут на клиенте. Если истёк, то можно завершать обработку запроса ошибкой.  
	* Burst limit - ограничение по кол-ву одновременно выполняемых запросов по фикс. кол-ву - не очень, потому что обрезается всё чуть больше заданного rps, хотя сервер мог бы обработать заданный rps + epsilon. Например, не более 100 запросов в секунду.  
	* Rate limit - Burst limit по стратегии - допускается превышение rps на небольшое число от заданного при условии последующего снижения их кол-ва. Например, не более 1000 запросов в 10 секунд. Хорошо сочетается с Burst limit по фикс. кол-ву, когда rps значительно превышает заданный. Например Rate limit на 1000 запросов в 10 секунд, но Burst limit на 200 запросов в секунду.  
	* Сircuit breaker  
	* Dummy - подушка безопасности. Упрощённая копия сервиса, без сложной логики и с минимумом зависимостей.
* Расскажи про идемпотентность? Что такое ключи идемпотентности? Что такое хранилище ключей идемпотентности?
Идемпотентность — это свойство операции, при котором её повторное выполнение с теми же входными данными не меняет результат. Она особенно важна в системах с сетевой задержкой, где одно и то же действие (например, запрос на создание или обновление ресурса) может быть выполнено несколько раз.  
  
Ключи идемпотентности — это уникальные идентификаторы, которые используются для отслеживания выполнения операций. Например, при выполнении транзакции мы можем назначить ей уникальный идентификатор (ключ идемпотентности), и если запрос с этим идентификатором уже обрабатывался, то система не будет повторно выполнять операцию, чтобы избежать дублирования.  
  
Хранилище ключей идемпотентности — БД, которая сохраняет информацию о ключах идемпотентности и их статусах. Обычно оно реализуется в базе данных, которая позволяет быстро проверять, была ли операция с данным ключом уже выполнена, и возвращать результат или игнорировать запрос, если он является повторным.(Redis)